name: Java API App CI/CD

# Trigger on push to main or PRs targeting main
on:
  pull_request:
    branches:
      - main  
  push:
    branches:
      - main

# Set default permissions required for OIDC and code access
permissions:
  id-token: write # Required for configure-aws-credentials
  contents: read  # Required for checkout

# Global Environment Variables
env:

  AWS_REGION: ${{ secrets.AWS_REGION }}

  ECR_REPOSITORY: utc-app
  JFROG_REPO_NAME: utc-app

jobs:

  # 1. SonarQube Scan Job
  sonar:
    name: Code Quality Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code (Full History)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for Sonar analysis

      - name: Setup Java 17 and Maven Cache
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: 17
          cache: 'maven'

      # Maven Cache is generally handled by setup-java@v3 cache: 'maven'
      # But you can add explicit cache for ~/.sonar/cache
      - name: Cache SonarQube package
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-sonar

      - name: Run Maven Build and Sonar Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          # The 'verify' goal runs tests; the sonar-maven-plugin:sonar runs the scan.
          # We use the env variables set by GHA secrets
          mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
            -Dsonar.projectKey=${{ env.ECR_REPOSITORY }} \
            -Dsonar.projectName=${{ env.ECR_REPOSITORY }} \
            -Dsonar.host.url=${{ env.SONAR_HOST_URL }} \
            -Dsonar.token=${{ env.SONAR_TOKEN }}

  # 2. Build and Artifact Upload Job
  build_and_upload:
    name: Build & Upload Artifacts
    runs-on: ubuntu-latest
    needs: sonar # Wait for the quality gate check to pass
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Java 17 and Maven Cache
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: 17
          cache: 'maven'

      - name: Package Application
        run: mvn -B clean package -DskipTests # Run package without tests here

      - name: Upload JAR file for later use (e.g., ECR/Deployment)
        uses: actions/upload-artifact@v4
        with:
          name: utc-app-jar
          path: target/*.jar  

      # **Deploy to JFrog (Artifactory)**
      - name: Read secrets from Vault
        uses: hashicorp/vault-action@v2
        with:
          url: ${{ secrets.VAULT_URL }}
          method: token
          token: ${{ secrets.VAULT_TOKEN }}
          exportEnv: true
          # Note: Exporting to temp env vars for security
          secrets: |
            secrets/creds/jfrog username | MAVEN_USERNAME_A ;
            secrets/creds/jfrog password | MAVEN_PASSWORD_A

      - name: Deploy to JFrog Artifactory
        env:
          MAVEN_USERNAME_A: ${{ env.MAVEN_USERNAME_A }}
          MAVEN_PASSWORD_A: ${{ env.MAVEN_PASSWORD_A }}
          ARTIFACTORY_URL: ${{ secrets.ARTIFACT_URL }} # Use secret directly here
        run: |
          # Extract version and artifactId from pom.xml
          APP_VERSION=$(grep -m2 '<version>' pom.xml | tail -1 | sed -n 's/.*<version>\([^<]*\).*/\1/p')
          APP_NAME=$(grep -m2 '<artifactId>' pom.xml | tail -1 | sed -n 's/.*<artifactId>\([^<]*\).*/\1/p')
          APP_LONG_NAME="$APP_NAME-$APP_VERSION.jar"
          
          # Use the artifact from the 'target' directory (created by package step)
          echo "Deploying $APP_LONG_NAME to Artifactory..."
          curl -f -u "$MAVEN_USERNAME_A:$MAVEN_PASSWORD_A" \
           -T "target/$APP_LONG_NAME" \
           -X PUT "${ARTIFACTORY_URL}/artifactory/${{ env.JFROG_REPO_NAME }}/$APP_LONG_NAME"


  # 3. Dockerize and Deploy Job
  deploy_container:
    name: Push Container & Deploy
    runs-on: ubuntu-latest
    needs: build_and_upload # Ensure build and artifact upload is complete
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Use the secret for the Role ARN
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image to ECR
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          # Explicitly define Dockerfile path
          file: ./Dockerfile 
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
      
      # Optional: Add ECS/EKS/other deployment steps here
      - name: Output Image URI for downstream deployment
        id: image-uri
        run: |
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"

          echo "uri=$IMAGE_URI" >> "$GITHUB_OUTPUT"

      - name: Debug - Image URI
        run: |
          echo "Final Image URI: ${{ steps.image-uri.outputs.uri }}"